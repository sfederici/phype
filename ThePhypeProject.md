## PhypeDoc table of contents ##
  1. [PhypeDoc](PhypeDoc.md)
  1. The Phype Project
  1. [Implementation](Implementation.md)
  1. [Testing](Testing.md)
  1. [Conclusions](Conclusions.md)

# The Phype Project #
Phype is a virtual machine for PHP written in JavaScript. Using the [JS/CC](http://jscc.jmksf.com/) automatic parser generator, and a context free PHP grammar, we have created a LALR(1) parser for PHP. This is in turn interpreted by our interpreter, which enables PHP code to run directly in the browser.

## First Steps ##
The first version of Phype was, as the current version, based on JavaScript and the PHP-extension _parsekit_. Parsekit translates PHP scripts into opcode arrays, containing Zend opcodes. These opcode arrays were then converted to JSON objects, to enable easier access.

We had a version up and running within the first week, and was able to parse, interpret and run some of the Zend opcodes, like echoing, assignment and declaration of variables, declaration and function calls.

Unfortunately, the output generated by parsekit contained a lot of references to hidden tables, which were internal to the Zend engine, and therefore inaccessible to us. This resulted in some inelegant regular expressions and hacks for parsing the PHP-code, and we basically ended up having to write an entire parser from scratch.

We decided that instead of writing our own PHP parser, we would go for generating a parser and interpreting the PHP-code from that output instead.

### Parsekit ###
Our initial implementation used a lot of arrays for saving variables, functions and arrays. This implementation worked well at the beginning, but as we got deeper and deeper into PHP, and parsekit, it became obvious that it was not the best way to do it.

As mentioned, parsekit outputs PHP scripts to an array of Zend opcodes. During this output, parsekit uses a multitude of hidden variables for saving all sorts of data: function names and parameters, array indices, variables, this-calls and more.

An opcode output by parsekit consists of one opcode which always has three arguments. If an argument is not used, it will contain the value unused. Otherwise an argument can contain either integers, strings, table-references, direct memory pointers or null. Both the table-references and memory pointers would reference values that were inaccessible.

For something as simple as variables, parsekit would use some index in a hidden table. Since this table was not available, we would have to parse the entire PHP-script, and use an incrementing counter to get the number of variables. The same was necessary for functions.

To implement variable scope, we needed an array of variables for each function, as well as a global variable array. Another pointer per function was needed for implementing nested function calls, since parsekit would implicitly reference the function table created by the Zend engine.

For arrays, parsekit would use one opcode per dimension, and a few opcodes for creating the array, using the values saved by the dimensional opcodes. This is when we realized that to properly implement even one-dimensional arrays, we would have to parse the PHP-string once more, and that we would end up implementing a PHP parser before we could start the real business of interpretation. We decided that we would be better off using a parser generator, rather than writing our own parser, and then get started on implementing an interpreter from scratch.

### JS/CC ###
After we dropped parsekit, we looked around for a parser generator for JavaScript to help us, and found the JS/CC Project. JS/CC is a JavaScript-based parser generator, that creates a LALR(1) parser written in JavaScript from a context-free grammar.

JS/CC included an example programming language, which included a small set of opcodes and a simple grammar. We took this and altered it significantly, to create a parser that would accomodate our needs for PHP.

The resulting grammar was inspired by [PHC's abstract PHP grammar](http://www.phpcompiler.org/doc/latest/grammar.html), but converted into the Bachus-Naur Form that is required for JS/CC to read it, and generate a parser from it, as well as rewritten to fit our implementation.

JS/CC gives us all the benefits of a LALR(1) parser, while giving us the possibility to create a grammer that fits our implementation perfectly. This means that our implementation is tailored specifically for PHP, and that the parser runs reasonably fast, and does not consume large amounts of memory for the parse tables.

## Planning ##
This is an overview of the goals and progress of the Phype project.

At first we need to read PHP-code and parse it. Then we implemented the basic PHP functionality; such as echoing and variables, and extend the interpreter with more advanced features, such as objects and constants. Finally we planned to do optimization, add a GC and access to library functions, to make Phype a complete PHP VM.

The project has been done with multiple small incremental changes to the codebase, so that we would not implement a large amount of features that did not work, but worked on one feature at a time. This meant that Phype was up and running fast, in both the parsekit and JS/CC versions, and that introduced bugs were easier to find and correct.

At the beginning of the project we set some rather big goals, but did not expect to fulfill them all. We expected to make an interpreter that would support a small subset of PHP, and we believe that we have done that.

The milestones below amount to our entire goals for Phype, but we did not reach the GC and library functions.

### Milestones ###
Below is an itemized list, from start to end, of the project milestones.
  * Reading PHP-code within `<script>`-tags.
  * Parsing PHP via LALR(1)-translatable grammar.
  * Interpreting PHP.
    * Echoing.
    * Binary and unary operations.
    * Type handling.
    * Assigning and reading variables.
    * Array declaration and access.
    * Declaring and calling functions.
    * Variable scope rules.
    * Conditional expressions and loops.
    * Declaring and accessing objects.
    * Constant declaration and access.
    * Requires and includes.
  * Garbage collection.
  * Library functions.

## Final Status ##
At the conclusion of this course, the Phype interpreter supports a subset of the general language features of PHP. As mentioned, we did not get any optimizations, garbage collection nor library functions running, but the interpreter works for a small subset of PHP.

In this section we will briefly mention which of the PHP language features are supported by Phype, and which that are not.

### Supported features ###
Phype currently supports these language features:
  * Echoing.
  * Arithmetic operations.
  * String concatenation.
  * Variable assignment and access.
  * Single dimensional arrays.
  * Conditional expressions and loops.
  * Function calls.
  * Object creation.
  * Non-static object member access.

### Unsupported features ###

Phype is missing a lot of syntactic sugar, and has some sematic differences to PHP:

  * Floats and doubles are parsed, but are not computed correctly.
  * Values in arithmetic operations are coerced to integers.
  * Function returns may fall through.
  * Error handling differs from PHP's.
  * Multidimensional arrays are bloated.

Some features were consciously omitted from Phype. These were:
  * Object inheritance.
  * String operations (except concatenation).
  * Libraries.